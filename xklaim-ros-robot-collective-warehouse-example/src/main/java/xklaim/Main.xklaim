package xklaim

import xklaim.arm.GetDown
import xklaim.arm.Grip
import xklaim.arm.GetUp
import xklaim.arm.Rotate
import xklaim.arm.Lay
import xklaim.arm.Release
import xklaim.arm.GoToInitialPosition
import xklaim.deliveryRobot.MoveToArm
import xklaim.deliveryRobot.DeliverItem

net RobotColl physical "localhost:9999" {
	node Arm {
		val rosbridgeWebsocketURI = "ws://0.0.0.0:9090"

		while (true) {
			in("initialPosition")@self

			in("item",var String itemType,var Double x_coordination, var Double y_coordination)@self

			eval(new GetDown(rosbridgeWebsocketURI, x_coordination, y_coordination))@self

			eval(new Grip(rosbridgeWebsocketURI))@self

			eval(new GetUp(rosbridgeWebsocketURI))@self

			eval(new Rotate(rosbridgeWebsocketURI, itemType))@self

			eval(new Lay(rosbridgeWebsocketURI))@self

			eval(new Release(rosbridgeWebsocketURI, itemType))@self

			eval(new GoToInitialPosition(rosbridgeWebsocketURI))@self
		}

	}

	node DeliveryRobot1 {
		val rosbridgeWebsocketURI = "ws://0.0.0.0:9090"
		val robotId = "robot1"

		while (true) {
			in("availableForDelivery")@self

			eval(new MoveToArm(rosbridgeWebsocketURI, robotId, Arm))@self

			eval(new DeliverItem(rosbridgeWebsocketURI, robotId, Arm))@self
		}
	}

	node DeliveryRobot2 {
		val rosbridgeWebsocketURI = "ws://0.0.0.0:9090"
		val robotId = "robot2"

		while (true) {
			in("availableForDelivery")@self

			eval(new MoveToArm(rosbridgeWebsocketURI, robotId, Arm))@self

			eval(new DeliverItem(rosbridgeWebsocketURI, robotId, Arm))@self
		}
	}

	node SimuationHandler {

		// --- initial setup of the scenario ---
		// insert info about positions of items in the arm robot's local knowledge (i.e., its tuple space)
		// call the delivery robot
		//
		/* Note: for the sake of simplicity here the tuples contain two lists of Double corresponding to the two 
		 * joint trajectories for the get down movements. It would preferable to indicate in the item tuples just 
		 * the coordinates of the items, so that the get down process would compute (also in some ad-hoc way) 
		 * the jointTrajectories for picking the item (however this could be not easy to do).   
		 */
		 
		out("item","typeA",0.30, -0.51)@Arm    //(x,y)coordinates item_1
	    out("item","typeB",0.491347, -0.322471)@Arm         //(x,y)coordinates item_2   		                                                    
	    out("item","typeC",0.583518, 0.0)@Arm               //(x,y)coordinates item_3
		out("item","typeD",0.504505, 0.3)@Arm                    //(x,y)coordinates item_4
		// insert mapping between item types and destinations in the delivery robots' local knowledge (i.e., their tuple spaces)
		/* Notably, different robot may use different mappings. Indeed we have three destinations
		 * (i.e., (12.0,34.0),(67.0,14.0) and (134.0,49.0)) and both delivery robots deliver items of type A 
		 * to the first destination, while items of type B are delivered at different destinations by the 
		 * two robots. Of course this is the idea, let us see how to better deal with this aspect of the scenario....
		 * 
		 */
		out("type2destination","typeA",-8.0,-8.80)@DeliveryRobot1
		out("type2destination","typeB",8.9,-8.3)@DeliveryRobot1
		out("type2destination","typeC",-8.0,-8.80)@DeliveryRobot2
		out("type2destination","typeD",8.9,-8.3)@DeliveryRobot2

		// activate the arm robot by inserting the information that it is in the initial position
		out("initialPosition")@Arm

		// activate the DeliveryRobot2 by inserting the information that it is available for a delivery
		out("availableForDelivery")@DeliveryRobot1

		// activate the DeliveryRobot1 by inserting the information that it is available for a delivery
		out("availableForDelivery")@DeliveryRobot2

		// activate the processes in charge of making the delivery items to disappear

	}

}
