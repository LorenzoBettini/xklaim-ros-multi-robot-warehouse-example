package xklaim

import java.util.List
import xklaim.arm.Disappear
import xklaim.arm.GetDown
import xklaim.arm.GetUp
import xklaim.arm.GoToInitialPosition
import xklaim.arm.Grip
import xklaim.arm.Lay
import xklaim.arm.Release
import xklaim.arm.Rotate
import xklaim.deliveryRobot.DeliverItem
import xklaim.deliveryRobot.MoveToArm

net RobotColl physical "localhost:9999" {
	node Arm {
		val rosbridgeWebsocketURI = "ws://0.0.0.0:9090"

		while (true) {
			in("initialPosition")@self

			in("item",var String itemType,var List<Double> firstTrajectoryPositions, var List<Double> secondTrajectoryPositions)@self

			eval(new GetDown(rosbridgeWebsocketURI, firstTrajectoryPositions, secondTrajectoryPositions))@self

			eval(new Grip(rosbridgeWebsocketURI))@self

			eval(new GetUp(rosbridgeWebsocketURI))@self

			eval(new Rotate(rosbridgeWebsocketURI))@self

			eval(new Lay(rosbridgeWebsocketURI))@self

			eval(new Release(rosbridgeWebsocketURI, itemType))@self

			eval(new GoToInitialPosition(rosbridgeWebsocketURI))@self

		}

	}

	node DeliveryRobot1 {
		val rosbridgeWebsocketURI = "ws://0.0.0.0:9090"
		val robotId = "robot1"

		while (true) {
			in("availableForDelivery")@self

			eval(new MoveToArm(rosbridgeWebsocketURI, robotId, Arm))@self

			eval(new DeliverItem(rosbridgeWebsocketURI, robotId, Arm))@self
		}
	}

	node DeliveryRobot2 {
		val rosbridgeWebsocketURI = "ws://0.0.0.0:9090"
		val robotId = "robot2"

		while (true) {
			in("availableForDelivery")@self

			eval(new MoveToArm(rosbridgeWebsocketURI, robotId, Arm))@self

			eval(new DeliverItem(rosbridgeWebsocketURI, robotId, Arm))@self
		}
	}

	node SimuationHandler {
		val rosbridgeWebsocketURI = "ws://0.0.0.0:9090"

		// --- initial setup of the scenario ---
		// insert info about positions of items in the arm robot's local knowledge (i.e., its tuple space)
		// call the delivery robot
		//
		/* Note: for the sake of simplicity here the tuples contain two lists of Double corresponding to the two 
		 * joint trajectories for the get down movements. It would preferable to indicate in the item tuples just 
		 * the coordinates of the items, so that the get down process would compute (also in some ad-hoc way) 
		 * the jointTrajectories for picking the item (however this could be not easy to do).   
		 */
		out("item","typeA",#[-3.14, -0.2169, -0.5822, 3.14, 1.66, -0.01412],#[-3.1415, -0.9975, -0.4970, 3.1400, 1.6613, -0.0142])@Arm
		out("item","typeB",#[-2.62, -0.2169, -0.5822, 3.14, 1.66, -0.01412],#[ -2.6208, -0.9975, -0.4970, 3.1400, 1.6613, -0.0142])@Arm // TODO: change the trajectories for the second item
		out("item","typeA",#[-2.5514, -0.2169, -0.5822, 3.14, 1.66, -0.01412],#[-2.5514, -0.9975,  -0.4970, 3.1400, 1.6613, -0.0142])@Arm // TODO: change the trajectories for the third item
		out("item","typeB",#[2.10000, -0.2169, -0.5822, 3.14, 1.66, -0.01412],#[2.10000, -0.9975, -0.4970, 3.1400, 1.6613,-0.0142])@Arm // TODO: change the trajectories for the fourth item
		// insert mapping between item types and destinations in the delivery robots' local knowledge (i.e., their tuple spaces)
		/* Notably, different robot may use different mappings. Indeed we have three destinations
		 * (i.e., (12.0,34.0),(67.0,14.0) and (134.0,49.0)) and both delivery robots deliver items of type A 
		 * to the first destination, while items of type B are delivered at different destinations by the 
		 * two robots. Of course this is the idea, let us see how to better deal with this aspect of the scenario....
		 * 
		 */
		out("type2destination","typeA",-8.0,-8.80)@DeliveryRobot1
		out("type2destination","typeB",8.9,-8.3)@DeliveryRobot1
		out("type2destination","typeA",9.35,8.60)@DeliveryRobot2
		out("type2destination","typeB",-8.41,8.3)@DeliveryRobot2

		// activate the arm robot by inserting the information that it is in the initial position
		out("initialPosition")@Arm

		// activate the DeliveryRobot2 by inserting the information that it is available for a delivery
		out("availableForDelivery")@DeliveryRobot1

		// activate the DeliveryRobot1 by inserting the information that it is available for a delivery
		out("availableForDelivery")@DeliveryRobot2

		// activate the processes in charge of making the delivery items to disappear
		eval(new Disappear(rosbridgeWebsocketURI, DeliveryRobot1))@self
		eval(new Disappear(rosbridgeWebsocketURI, DeliveryRobot2))@self
	}

}
