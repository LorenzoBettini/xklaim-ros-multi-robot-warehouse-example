package xklaim

import xklaim.arm.GetDown
import xklaim.arm.Grip
import xklaim.arm.GetUp
import xklaim.arm.Rotate
import xklaim.arm.Lay
import xklaim.arm.Release
import xklaim.arm.GoToInitialPosition
import xklaim.deliveryRobot.MoveToArm
import xklaim.deliveryRobot.DeliverItem

net RobotColl physical "localhost:9999" {
	node Arm {
		val rosbridgeWebsocketURI = "ws://0.0.0.0:9090"
		while (true) {
			in("initialPosition")@self

			in("item",var String itemId,var String itemType,var Double x, var Double y)@self

			eval(new GetDown(rosbridgeWebsocketURI, x, y))@self

			eval(new Grip(rosbridgeWebsocketURI))@self

			eval(new GetUp(rosbridgeWebsocketURI, x, y))@self

			eval(new Rotate(rosbridgeWebsocketURI))@self

			eval(new Lay(rosbridgeWebsocketURI))@self

			eval(new Release(rosbridgeWebsocketURI, itemId, itemType))@self

			eval(new GoToInitialPosition(rosbridgeWebsocketURI))@self

		}

	}

	node DeliveryRobot1 {
		val rosbridgeWebsocketURI = "ws://0.0.0.0:9090"
		val robotId = "robot1"

		while (true) {
			in("availableForDelivery")@self

			eval(new MoveToArm(rosbridgeWebsocketURI, robotId, Arm))@self

			eval(new DeliverItem(rosbridgeWebsocketURI, robotId, Arm))@self
		}
	}

	node DeliveryRobot2 {
		val rosbridgeWebsocketURI = "ws://0.0.0.0:9090"
		val robotId = "robot2"

		while (true) {
			in("availableForDelivery")@self

			eval(new MoveToArm(rosbridgeWebsocketURI, robotId, Arm))@self

			eval(new DeliverItem(rosbridgeWebsocketURI, robotId, Arm))@self
		}
	}

	node SimuationHandler {

		// --- initial setup of the scenario ---
		// insert info about positions of items in the arm robot's local knowledge (i.e., its tuple space)
		// call the delivery robot
		//
		/* Note: for the sake of simplicity here the tuples contain two lists of Double corresponding to the two 
		 * joint trajectories for the get down movements. It would preferable to indicate in the item tuples just 
		 * the coordinates of the items, so that the get down process would compute (also in some ad-hoc way) 
		 * the jointTrajectories for picking the item (however this could be not easy to do).   
		 */
		 
		 
		out("item","idem1","typeA",0.583518, 0.0)@Arm    //(x,y)coordinates item_1 
	    out("item","idem2","typeB",0.554542, 0.187360)@Arm         //(x,y)coordinates item_2 	
	    out("item","idem3","typeA",0.504, 0.307)@Arm   //(x,y)coordinates item_3	                                                    
	    out("item","idem4","typeB",0.332977,0.470854)@Arm    //(x,y)coordinates item_4
		                 
		// insert mapping between item types and destinations in the delivery robots' local knowledge (i.e., their tuple spaces)
		/* Notably, different robot may use different mappings. Indeed we have three destinations
		 * (i.e., (12.0,34.0),(67.0,14.0) and (134.0,49.0)) and both delivery robots deliver items of type A 
		 * to the first destination, while items of type B are delivered at different destinations by the 
		 * two robots. Of course this is the idea, let us see how to better deal with this aspect of the scenario....
		 * 
		 */
		out("type2destination","idem1","typeA",-8.0,-8.80)@DeliveryRobot1
		out("type2destination","idem2","typeB",-8.41,8.5)@DeliveryRobot2
		out("type2destination","idem3","typeA",9.34,8.65)@DeliveryRobot1
		out("type2destination","idem4","typeB",8.9,-8.5)@DeliveryRobot2

		// activate the arm robot by inserting the information that it is in the initial position
		out("initialPosition")@Arm

		// activate the DeliveryRobot2 by inserting the information that it is available for a delivery
		out("availableForDelivery")@DeliveryRobot1

		// activate the DeliveryRobot1 by inserting the information that it is available for a delivery
		out("availableForDelivery")@DeliveryRobot2

		// activate the processes in charge of making the delivery items to disappear

	}

}