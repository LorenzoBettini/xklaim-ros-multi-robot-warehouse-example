package xklaim

import java.ModelState
import ros.Publisher
import ros.RosBridge
import xklaim.arm.GetDown
import xklaim.arm.GetUp
import xklaim.arm.GoToInitialPosition
import xklaim.arm.Grip
import xklaim.arm.Lay
import xklaim.arm.Release
import xklaim.arm.Rotate
import xklaim.deliveryRobot.DeliverItem
import xklaim.deliveryRobot.MovetoArm

net RobotColl physical "localhost:9999" {
	node Arm {
		
		// while true seguita da in della tupla dell'item
		
		val rosbridgeWebsocketURI = "ws://0.0.0.0:9090"

		eval(new GetDown(rosbridgeWebsocketURI))@self

		eval(new Grip(rosbridgeWebsocketURI))@self

		eval(new GetUp(rosbridgeWebsocketURI))@self


// tutte le comunicazioni avvengono su self per l'arm
// non mi serve avere info del deliveryRobot
		eval(new Rotate(rosbridgeWebsocketURI, DeliveryRobot1))@self

		eval(new Lay(rosbridgeWebsocketURI, DeliveryRobot1))@self

		eval(new Release(rosbridgeWebsocketURI, DeliveryRobot1))@self

		eval(new GoToInitialPosition(rosbridgeWebsocketURI, DeliveryRobot1))@self

	}
	
	node DeliveryRobot1 {
		val rosbridgeWebsocketURI = "ws://0.0.0.0:9090"

	// while true

		eval(new MovetoArm(rosbridgeWebsocketURI, Arm))@self

		eval(new DeliverItem(rosbridgeWebsocketURI))@self
	}
	
	node DeliveryRobot2 {
		val rosbridgeWebsocketURI = "ws://0.0.0.0:9090"

	// while true

		eval(new MovetoArm(rosbridgeWebsocketURI, Arm))@self

		eval(new DeliverItem(rosbridgeWebsocketURI))@self
	}
	
	node SimuationHandler {
		val rosbridgeWebsocketURI = "ws://0.0.0.0:9090"

		// create the bridge and connect it to the ROS bridge
		val bridge = new RosBridge()
		bridge.connect(rosbridgeWebsocketURI, true)

		// initial setup of the scenario
		
		// mettiamo delle out delle posizioni degl item nel robot arm
		
		// mettiamo la logica di delivery nei delivery robot che mappano il tipo dell'item con la destinazione
		
		
		
		
		
		
		
		in("itemDelivered")@DeliveryRobot1

		Thread.sleep(2000)
		
		// make the item disappear
		val gazebo = new Publisher("/gazebo/set_model_state", "gazebo_msgs/ModelState", bridge)
		val modelstate = new ModelState()
		modelstate.twist.linear.x = 3.0
		modelstate.twist.angular.z = 1.0
		modelstate.pose.position.x = -46.0
		modelstate.pose.position.y = 46.0
		modelstate.pose.position.z = 0.0
		modelstate.model_name = "unit_box_2"
		modelstate.reference_frame = "world"
		gazebo.publish(modelstate)
		
		
		in("initialPositionReached")@Arm
		
		// stop the overall execution
		System.exit(0)

	}

}
